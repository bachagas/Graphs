package datastructures;

import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class Graph {
	/*
	 * Main structure of the class. Defines all nodes and edges of the graph. The keys of the map are the graph's 
	 * nodes and its values are each a set of neighbors of that key-node.
	 */
	private Map<Node, Set<Node>> graphMap;
	
	/*
	 * Temporary structure to define which of the graph nodes were visited by the DFS and BFS algorithms
	 */
	private Set<Node> visitedSet = null;
	
	/*
	 * Temporary structure that stores the current tree generated by the traverse algorithms (DFS and BFS).
	 */
	private Map<Node, Set<Node>> traverseTreeMap = null;
	
	/*
	 * After the DFS algorithm is called, this structure will contain all the connected components of the original graph,
	 * each modeled as a single graph of its own.
	 * Obs.: List interface chosen instead of Set interface to preserve order. Nevertheless all nodes of this list
	 * should be distinct.
	 */
	private List<Graph> connectedComponents = null;
	
	public Graph() {
		this.graphMap = new HashMap<Node, Set<Node>>();
	}
	
	public Graph( int initialCapacity ) {
		this.graphMap = new HashMap<Node, Set<Node>>( initialCapacity );
	}
	
	public Graph( Map<Node, Set<Node>> graphMap ) {
		//TODO
		this.graphMap = graphMap;
	}
	
	public boolean isDefinedConnectedComponents() {
		boolean defined = connectedComponents != null;
		return defined;
	}
	
	public List<Graph> getConnectedComponents() throws UndefinedConnectedComponentsException {
		if( !this.isDefinedConnectedComponents() ) {
			throw new UndefinedConnectedComponentsException();
		}
		
		return this.connectedComponents;
	}
	
	/*
	public Node getRandomNode() {
		Set<Node> nodeSet = this.graphMap.keySet();
		Iterator<Node> it = nodeSet.iterator();
		//TODO Melhorar isso, pq não está realmente random
		for( Node next = it.next(); next != null; next = it.next() ) {
			return next;
		}
		
		return null;
	}
	*/
	
	public Set<Node> getNodeSet() {
		Set<Node> keySet = this.graphMap.keySet();
		return keySet;
	}
	
	public Set<Node> getNeighbors(Node node) {
		Set<Node> neighbors = this.graphMap.get(node);
		return neighbors;
	}
	
	protected void traverseReset() {
		this.traverseTreeMap = new HashMap<Node, Set<Node>>();
		this.visitedSet = new HashSet<Node>();
	}
	
	private boolean isVisited(Node node) {
		boolean contains = this.visitedSet.contains(node);
		
		return contains;
	}
	
	private void markVisited(Node node) {
		this.visitedSet.add(node);
	}
	
	public void dfs() {
		traverseReset();
		
		/*
		 *  Graph is usually assumed completely built at this point, 
		 *  with ALL possible configuration nodes and corresponding edges.
		 *  This method should still run correctly even if the graph is empty though.
		 */
		
		// Initialize connected components as an empty list
		this.connectedComponents = new LinkedList<Graph>();
		
		Set<Node> nodeSet = this.getNodeSet();
		Iterator<Node> it = nodeSet.iterator();
		
		// Iterate through all nodes in the graph
		for( Node nextNode = it.next(); nextNode != null; nextNode = it.next() ) {
			boolean visited = this.isVisited(nextNode);
			if( !visited ) {
				dfsVisit(nextNode);
				
				// At this point, one can deduce nextNode's connected component through the current DFS Tree
				Map<Node, Set<Node>> connectedComponentMap = new HashMap<Node, Set<Node>>();
				
				// Get all nodes from the DFS tree, i.e., all nodes from the current connected component
				Set<Node> dfsTreeKeys = this.traverseTreeMap.keySet();
				Iterator<Node> itDFSTree = dfsTreeKeys.iterator();
				for( Node nextDFSTreeNode = itDFSTree.next(); nextDFSTreeNode != null; nextDFSTreeNode = itDFSTree.next() ) {
					// For each node in the DFS tree, add it to the connected component map
					Set<Node> neighbors = this.getNeighbors(nextDFSTreeNode);
					connectedComponentMap.put(nextDFSTreeNode, neighbors);
				}
				
				// Create a new graph that represents a connected component of the original graph
				Graph connectedComponent = new Graph(connectedComponentMap);
				// Add the connected component to the connected components list
				this.connectedComponents.add(connectedComponent);
				
				// Reset the DFS tree
				this.traverseTreeMap = new HashMap<Node, Set<Node>>();
			}
		}
	}
	
	public boolean isEmpty() {
		Set<Node> nodeSet = this.getNodeSet();
		boolean empty = nodeSet.isEmpty();
		return empty;
	}
	
	private void dfsAddEdge(Node fromNode, Node toNode) {
		Set<Node> treeNodeNeighbors = this.traverseTreeMap.get(fromNode);
		if( treeNodeNeighbors == null ) {
			// This usage does not tolerate null values associated to the map's keys
			assert(!this.traverseTreeMap.containsKey(fromNode)); // TODO verificar complexidade desta operação e correto uso do assert
			
			// If node is not yet in the dfsTree, insert it
			treeNodeNeighbors = new HashSet<Node>();
			this.traverseTreeMap.put(fromNode, treeNodeNeighbors);
		}
		
		// Insert 'from'-'to' edge into dfsTree
		treeNodeNeighbors.add(toNode);
	}
	
	private void dfsVisit(Node node) {
		// Mark node as visited
		this.markVisited(node);
		
		Set<Node> neighbors = this.getNeighbors(node);
		Iterator<Node> it = neighbors.iterator();
		for( Node next = it.next(); next != null; next = it.next() ) {
			boolean visited = this.isVisited(next);
			if( !visited ) {
				// Insert 'node'-'next' edge into dfsTree
				this.dfsAddEdge(node, next);
				
				// Visit next node
				dfsVisit(next);
			}
		}
	}
	
	protected void addNode(Node node, Set<Node> neighbors) {
		this.graphMap.put(node, neighbors);
	}
}
